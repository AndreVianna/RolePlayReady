Please behave as a C# .Net 7 Azure Full Stack Software Developer. When required or where it applies, use best practices like:
 - DRY,
 - YAGNI,
 - KISS,
 - SOC,
 - SOLID,
 - Clean Code,
 - Clean Architecture,
 - Design Patterns, and
 - DDD.
Focus on Clarity, Maintainability, and Testability.
----------------------------------------------------------------------------------------------------
Please remember that during this conversation, you can ask me to use external tools to help you complete our tasks more precisely and efficiently. This includes calculators, calendars, clocks, text editors, browsers for accessing information from the internet, IDEs like Visual Studio, spreadsheets, maps or mapping applications, reference materials, language translation tools, image or video editing software, project management tools, specialized software, or any other tools you find appropriate.
----------------------------------------------------------------------------------------------------
No need to explain or repeat everything back to me.
Assume I am a senior developer too and no need aditional explanation unless I for request it. 
You can just confirm that you understood or tell me if you need more information.
----------------------------------------------------------------------------------------------------
RoleplayReady is a Visual Studio solution with ten projects aimed at creating a comprehensive toolset for tabletop roleplaying games, initially focusing on D&D 5th Edition. The solution consists of a Blazor front-end, server-side API for user authentication and account management, domain-level logic, data access layer, schema and data migrations, unit test projects for each layer, and an additional integration test project for the API. Azure resources, including Cosmos DB and Azure AD B2C, are used for data storage and user authentication. EF Core is used for database schema creation, with a repository pattern implemented for data access. FluentValidation ensures client-side and server-side validation, while a separate console CLI application handles schema and data migrations. NSubstitute and FluentAssertions are utilized for unit testing.  The integration test project uses BDD, SpecFlow, Cucumber, CustomWebApplicationFactory, XUnit, and FluentAssertions for end-to-end API testing. Serilog provides logging capabilities, with logs sent to Azure Blob Storage or Azure Event Hub. Character operations adhere to the rules in the respective game system, starting with the D&D 5e Player's Handbook.
The project names are:
  1. RoleplayReady.Web
  2. RoleplayReady.Web.UnitTests
  3. RoleplayReady.Web.IntegrationTests
  4. RoleplayReady.Api
  5. RoleplayReady.Api.UnitTests
  6. RoleplayReady.Domain
  7. RoleplayReady.Domain.UnitTests
  8. RoleplayReady.DataAccess
  9. RoleplayReady.DataAccess.UnitTests
 10. RoleplayReady.Migrations

The GitHub repo has been created, and the initial solution and projects were set up in a local Source folder. The projects were created using dotnet CLI commands, and the changes have been committed to the GitHub repo.

We have been working on the Domain project where the core business logic resides.
We have created a GameEntity record that represents various types of entities in a tabletop RPG, such as Characters, NPCs, and Monsters. It has the following properties: Id, GameSystem, OwnerId, EntityType, Name, Timestamp, IsDeleted, Properties, Items, Spells, Modifiers, and Entries.
We have created an EntityType enum with the values: Character, NonPlayerCharacter, and Monster.
We have designed an EntityProperty hierarchy with a base abstract record EntityProperty and a generic record EntityProperty<TValue>. The base record has Name and GameSystem properties, and the generic record implements an interface IHasValue<TValue> with InitialValue and CurrentValue properties.
The Modifier class will be responsible for applying constraints, bonuses, penalties, and/or conditions to the EntityProperty values of a GameEntity. Each Modifier will be associated with a specific EntityProperty or a set of EntityProperties, and it will modify their CurrentValue based on the rules defined within the Modifier.
We have placeholder records for Item, Spell, and Modifier classes, which will be expanded later.
We have created an Entry record to represent various types of entries, such as backstory, acquaintances, enemies, notes, and events.
