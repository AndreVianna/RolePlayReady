Please behave as a C# .Net 7 Software Developer.
When required or where it applies, use best practices like:
 - DRY,
 - YAGNI,
 - KISS,
 - SOC,
 - SOLID,
 - Clean Code,
 - Clean Architecture,
 - Design Patterns, and
 - DDD.
Focus on Clarity, Maintainability, and Testability.
----------------------------------------------------------------------------------------------------
No need to explain or repeat everything back to me.
Assume I am also a senior developer and only need additional explanation if requested. 
During this conversation, you can confirm that you understood a request or tell me if you need more information.
Keep messages brief and to the point.
When showing changes in a code, avoid repeating the whole thing. Just send me the deltas.
You don't need to say, "If you have any other questions or need further assistance, feel free to ask!". I know you are always available and willing to help.
----------------------------------------------------------------------------------------------------
RoleplayReady is a Visual Studio solution with ten projects aimed at creating a comprehensive toolset for tabletop roleplaying games, initially focusing on D&D 5th Edition. The solution consists of a Blazor front-end, server-side API for user authentication and account management, domain-level logic, data access layer, schema and data migrations, unit test projects for each layer, and an additional integration test project for the API. Azure resources, including Cosmos DB and Azure AD B2C, are used for data storage and user authentication. EF Core is used for database schema creation, with a repository pattern implemented for data access. FluentValidation ensures client-side and server-side validation, while a separate console CLI application handles schema and data migrations. NSubstitute and FluentAssertions are utilized for unit testing.  The integration test project uses BDD, SpecFlow, Cucumber, CustomWebApplicationFactory, XUnit, and FluentAssertions for end-to-end API testing. Serilog provides logging capabilities, with logs sent to Azure Blob Storage or Azure Event Hub. Character operations adhere to the rules in the respective game system, starting with the D&D 5e Player's Handbook.
The project names are:
  1. RoleplayReady.Web
  2. RoleplayReady.Web.UnitTests
  3. RoleplayReady.Web.IntegrationTests
  4. RoleplayReady.Api
  5. RoleplayReady.Api.UnitTests
  6. RoleplayReady.Domain
  7. RoleplayReady.Domain.UnitTests
  8. RoleplayReady.DataAccess
  9. RoleplayReady.DataAccess.UnitTests
 10. RoleplayReady.Migrations

The GitHub repo has been created, and the initial solution and projects were set up in a local Source folder. The projects were created using dotnet CLI commands, and the changes have been committed to the GitHub repo.

We strated working on the working on the Domain project where the core business logic resides.
We have created a GameEntity record that represents various types of entities in a tabletop RPG, such as Characters, NPCs, and Monsters. It has the following properties: Id, GameSystem, OwnerId, EntityType, Name, Timestamp, IsDeleted, Properties, Items, Spells, Modifiers, and Entries.
We have created an EntityType enum with the values: Character, NonPlayerCharacter, and Monster.
We have designed an EntityProperty hierarchy with a base abstract record EntityProperty and a generic record EntityProperty<TValue>. The base record has Name and GameSystem properties, and the generic record implements an interface IHasValue<TValue> with InitialValue and CurrentValue properties.
The Modifier class will be responsible for applying constraints, bonuses, penalties, and/or conditions to the EntityProperty values of a GameEntity. Each Modifier will be associated with a specific EntityProperty or a set of EntityProperties, and it will modify their CurrentValue based on the rules defined within the Modifier.
We have placeholder records for Item, Spell, and Modifier classes, which will be expanded later.
We have created an Entry record to represent various types of entries, such as backstory, acquaintances, enemies, notes, and events.

After that we strated working on the Modifers class.
We started with an initial code block that defines a SetGameSystemModifiers method and adds an InitializeMonster modifier. The original code included a set of basic properties and validations for the Monster entity.
We refined and expanded the list of properties for the Monster entity, including additional properties from the DnD 5e core rules. This resulted in multiple iterations of the property list for the Monster entity.
We identified the shared properties among Monsters, NPCs, and Characters, and moved them to a separate list that could be applied to all entity types. We then created separate lists for the properties exclusive to Monsters and NPCs.
We discussed the possibility of Monsters having Spellcasting Abilities, Spell Slots, and Spells Known. Consequently, we updated the Monster property list to include these attributes.
We identified the properties exclusive to Characters and refined the property list for the Character entity. This included updating the properties to better represent the DnD 5e rules, such as handling multiclassing with a Class record.
We considered additional properties for Characters, like Carrying Weight and personal traits. However, these properties were not added to the code, as they are more suitable for a more detailed character sheet.
Throughout the conversation, we have been updating the code to better represent the properties and structure of Monsters, NPCs, and Characters in the context of the DnD 5e system.


public abstract record Entity : IEntity {
    protected Entity() { }

    // Hierarchy setting
    public IEntity? Parent { get; init; } // Tree root should always be a RuleSet.

    public required string OwnerId { get; init; } // "System" represents the entitis crested by the app, otherwise should be the user guid.
    // (OwnerId + Parent + Abbreviation) must be unique.
    public required string Abbreviation { get; init; }
    // (OwnerId + Parent + Name) must also be unique.
    public required string Name { get; init; }
    public required Description { get; init; }

    // Tracking and Visibility
    public DateTime Timestamp { get; init; } = DateTime.UtcNow;
    public Status Status { get; init; } = Status.NotReady;
}

// Represents a game system: DnD5e, Pathfinder, Star Trek, Call of Cthulhu, etc
public record RuleSet : Entity, IRuleSet {
    public IList<ISource> Sources { get; } = new List<ISource>();
    public IList<IComponent> Components { get; } = new List<IComponent>();
    public IList<IActor> Actors { get; } = new List<IActor>();
    public IList<IProcess> Processs { get; } = new List<IProcess>();
}

// Represents a publication: Player's Handbook (PHB), Dungeon Master's Guide (DMG), etc
public record Source : ISource {
    // Abbreviation must be unique.
    public required string Abbreviation { get; init; }
    // Name must also be unique.
    public required string Name { get; init; }
    public string? Description { get; init; }
    public string? Publisher { get; init; }
}

public record Attribute : Entity, IAttribute {
    public required Type DataType { get; init; }
}

public enum Usage { Standard, Template, Closed }
public enum Status { NotReady, Public, Private, Retired }

public record Element : Entity, IElement {
    public Element() { }

    [SetsRequiredMembers]
    public Element(IEntity parent, string ownerId, string name, string description, State state, Usage? usage = null, ISource? source = null)
        : base(parent, ownerId, name, description, state) {
        Usage = usage ?? (parent as IElement)?.Usage ?? Usage.Standard;
        Source = source ?? (parent as IElement)?.Source;
    }

    public required Usage Usage { get; init; }
    public ISource? Source { get; init; }

    public IList<string> Tags { get; } = new List<string>();

    public IList<IValidation> Requirements { get; } = new List<IValidation>();
    public IList<IElementAttribute> Attributes { get;  = new List<IElementAttribute>();
    public IList<IValidation> Validations { get; } = new List<IValidation>();

    public IList<ITrait> Traits { get; } = new List<ITrait>();
    public IList<IPowerSource> PowerSources { get; } = new List<IPowerSource>();
    public IList<IEffects> Effects { get; } = new List<IEffects>();
    public IList<ITrigger> Triggers { get; } = new List<ITrigger>();
}

public record Validation : IValidation {
    public required Func<IElement, bool> Validate { get; init; }
    public required string FailureMessage { get; init; }
}

public record Effect : IEffects {
    public required Func<IElement, IElement> Apply { get; init; } = _ => _;
}

public abstract record ElementAttribute : IElementAttribute {
    protected ElementAttribute() { }

    // Element + Attribute must be unique;
    public required IEntity Parent { get; init; }
    public required IElement Element { get; init; }
    public required IAttribute Attribute { get; init; }
    public object? Value { get; set; }
}

public record ElementAttribute<TValue> : ElementAttribute, IElementAttribute<TValue> {
    public new required TValue? Value { get; set; }

    object? IHaveValue.Value {
        get => Value;
        set => Value = (TValue?)value;
    }
}

public record Trait : Element, ITrait { }
public record PowerSource : Element, ITrait { }
public record Trigger : Element, ITrait { }

public record Actor : Element, IActor {
    public IList<IPossession> Possessions { get; init; } = new List<IPossession>();
    public IList<IPower> Powers { get; init; } = new List<IPower>();
    public IList<IAction> Actions { get; init; } = new List<IAction>();
    public IList<ICondition> Conditions { get; init; } = new List<ICondition>();
    public IList<IJournalEntry> JournalEntries { get; init; } = new List<IJournalEntry>();
}

public record Possession : IPossession {
    public required IEntity Parent { get; init; }
    public required IObject Object { get; init; }
    public required decimal Quantity { get; init; }
}

public record Object : Element, IObject {
    public required string Unit { get; init;  }
}

public record Power : Element, IPower { }
public record Action : Element, IPower { }
public record Condition : Element, IPower { }

public record JournalEntry : IJournalEntry {
    public required IEntity Parent { get; init; }
    public required JournalEntrySection Section { get; init; }
    public required string Title { get; init; }
    public required string Text { get; init; }

    public DateTime Timestamp { get; init; } = DateTime.UtcNow;
    public State State { get; init; }
}

public record Process : Element, IProcess {
    public required IProcessStep Start { get; init; }
}

public record ProcessStep : IProcessStep {
    public required IProcess Parent { get; init; }
    public required string Name { get; init; }
    public required string Description { get; init; }
    public required Func<IEntity, IProcessStep?> Execute { get; init; } // returns next step or null to terminate.
}