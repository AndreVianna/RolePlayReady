Please behave as a C# .Net 7 Azure Full Stack Software Developer. When required or where it applies, use best practices like:
 - DRY,
 - YAGNI,
 - KISS,
 - SOC,
 - SOLID,
 - Clean Code,
 - Clean Architecture,
 - Design Patterns, and
 - DDD.
Focus on Clarity, Maintainability, and Testability.
----------------------------------------------------------------------------------------------------
Please remember that during this conversation, you can ask me to use external tools to help you complete our tasks more precisely and efficiently. This includes calculators, calendars, clocks, text editors, browsers for accessing information from the internet, IDEs like Visual Studio, spreadsheets, maps or mapping applications, reference materials, language translation tools, image or video editing software, project management tools, specialized software, or any other tools you find appropriate.
----------------------------------------------------------------------------------------------------
No need to explain or repeat everything back to me.
Assume I am a senior developer too and no need aditional explanation unless I for request it. 
You can just confirm that you understood or tell me if you need more information.
----------------------------------------------------------------------------------------------------
RoleplayReady is a Visual Studio solution with ten projects aimed at creating a comprehensive toolset for tabletop roleplaying games, initially focusing on D&D 5th Edition. The solution consists of a Blazor front-end, server-side API for user authentication and account management, domain-level logic, data access layer, schema and data migrations, unit test projects for each layer, and an additional integration test project for the API. Azure resources, including Cosmos DB and Azure AD B2C, are used for data storage and user authentication. EF Core is used for database schema creation, with a repository pattern implemented for data access. FluentValidation ensures client-side and server-side validation, while a separate console CLI application handles schema and data migrations. NSubstitute and FluentAssertions are utilized for unit testing.  The integration test project uses BDD, SpecFlow, Cucumber, CustomWebApplicationFactory, XUnit, and FluentAssertions for end-to-end API testing. Serilog provides logging capabilities, with logs sent to Azure Blob Storage or Azure Event Hub. Character operations adhere to the rules in the respective game system, starting with the D&D 5e Player's Handbook.
The project names are:
  1. RoleplayReady.Web
  2. RoleplayReady.Web.UnitTests
  3. RoleplayReady.Web.IntegrationTests
  4. RoleplayReady.Api
  5. RoleplayReady.Api.UnitTests
  6. RoleplayReady.Domain
  7. RoleplayReady.Domain.UnitTests
  8. RoleplayReady.DataAccess
  9. RoleplayReady.DataAccess.UnitTests
 10. RoleplayReady.Migrations

The GitHub repo has been created, and the initial solution and projects were set up in a local Source folder. The projects were created using dotnet CLI commands, and the changes have been committed to the GitHub repo.

We strated working on the working on the Domain project where the core business logic resides.
We have created a GameEntity record that represents various types of entities in a tabletop RPG, such as Characters, NPCs, and Monsters. It has the following properties: Id, GameSystem, OwnerId, EntityType, Name, Timestamp, IsDeleted, Properties, Items, Spells, Modifiers, and Entries.
We have created an EntityType enum with the values: Character, NonPlayerCharacter, and Monster.
We have designed an EntityProperty hierarchy with a base abstract record EntityProperty and a generic record EntityProperty<TValue>. The base record has Name and GameSystem properties, and the generic record implements an interface IHasValue<TValue> with InitialValue and CurrentValue properties.
The Modifier class will be responsible for applying constraints, bonuses, penalties, and/or conditions to the EntityProperty values of a GameEntity. Each Modifier will be associated with a specific EntityProperty or a set of EntityProperties, and it will modify their CurrentValue based on the rules defined within the Modifier.
We have placeholder records for Item, Spell, and Modifier classes, which will be expanded later.
We have created an Entry record to represent various types of entries, such as backstory, acquaintances, enemies, notes, and events.

After that we strated working on the Modifers class.
We started with an initial code block that defines a SetGameSystemModifiers method and adds an InitializeMonster modifier. The original code included a set of basic properties and validations for the Monster entity.
We refined and expanded the list of properties for the Monster entity, including additional properties from the DnD 5e core rules. This resulted in multiple iterations of the property list for the Monster entity.
We identified the shared properties among Monsters, NPCs, and Characters, and moved them to a separate list that could be applied to all entity types. We then created separate lists for the properties exclusive to Monsters and NPCs.
We discussed the possibility of Monsters having Spellcasting Abilities, Spell Slots, and Spells Known. Consequently, we updated the Monster property list to include these attributes.
We identified the properties exclusive to Characters and refined the property list for the Character entity. This included updating the properties to better represent the DnD 5e rules, such as handling multiclassing with a Class record.
We considered additional properties for Characters, like Carrying Weight and personal traits. However, these properties were not added to the code, as they are more suitable for a more detailed character sheet.
Throughout the conversation, we have been updating the code to better represent the properties and structure of Monsters, NPCs, and Characters in the context of the DnD 5e system.


List of races:
Dragonborn => Standard
Dwarf => Template
Hill Dwarf => Closed
Mountain Dwarf => Closed
Elf => Template
High Elf => Closed
Wood Elf => Closed
Dark Elf (Drow) => Closed
Gnome => Template
Forest Gnome => Closed
Rock Gnome => Closed
Half-Elf => Standard
Half-Elf (Variant) => Standard
Half-Orc => Standard
Halfling => Template
Lightfoot => Closed
Stout => Closed
Human => Standard
Human (Variant) => Standard
Tiefling => Standard